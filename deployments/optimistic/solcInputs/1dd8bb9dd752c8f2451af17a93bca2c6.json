{
  "language": "Solidity",
  "sources": {
    "contracts/governance/GovernorMultisig.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.6;\n\nimport \"./Multiownable.sol\";\n\ncontract GovernorMultisig is Multiownable {\n  /// @notice The maximum number of actions that can be included in a transaction\n  uint256 public constant MAX_OPERATIONS = 10; // 10 actions\n\n  /**\n   * @notice Execute target transactions with multisig.\n   * @param targets Target addresses for transaction calls\n   * @param values Eth values for transaction calls\n   * @param signatures Function signatures for transaction calls\n   * @param calldatas Calldatas for transaction calls\n   */\n  function executeTransaction(\n    address[] memory targets,\n    uint256[] memory values,\n    string[] memory signatures,\n    bytes[] memory calldatas\n  ) external onlyManyOwners {\n    require(\n      targets.length == values.length && targets.length == signatures.length && targets.length == calldatas.length,\n      \"GovernorMultisig::executeTransaction: function information arity mismatch\"\n    );\n    require(targets.length != 0, \"GovernorMultisig::executeTransaction: must provide actions\");\n    require(targets.length <= MAX_OPERATIONS, \"GovernorMultisig::executeTransaction: too many actions\");\n\n    for (uint8 i = 0; i < targets.length; i++) {\n      bytes memory callData = bytes(signatures[i]).length == 0\n        ? calldatas[i]\n        : abi.encodePacked(bytes4(keccak256(bytes(signatures[i]))), calldatas[i]);\n\n      // solhint-disable-next-line avoid-low-level-calls\n      (bool success, ) = targets[i].call{value: values[i]}(callData);\n      require(success, \"GovernorMultisig::executeTransaction: transaction execution reverted\");\n    }\n  }\n}\n"
    },
    "contracts/governance/Multiownable.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.6;\n\n/// @author https://github.com/bitclave/Multiownable\n// solhint-disable private-vars-leading-underscore\ncontract Multiownable {\n  // VARIABLES\n  uint256 public ownersGeneration;\n  uint256 public howManyOwnersDecide;\n  address[] public owners;\n  bytes32[] public allOperations;\n  address internal insideCallSender;\n  uint256 internal insideCallCount;\n\n  // Reverse lookup tables for owners and allOperations\n  mapping(address => uint256) public ownersIndices; // Starts from 1\n  mapping(bytes32 => uint256) public allOperationsIndicies;\n\n  // Owners voting mask per operations\n  mapping(bytes32 => uint256) public votesMaskByOperation;\n  mapping(bytes32 => uint256) public votesCountByOperation;\n\n  // EVENTS\n\n  event OwnershipTransferred(\n    address[] previousOwners,\n    uint256 howManyOwnersDecide,\n    address[] newOwners,\n    uint256 newHowManyOwnersDecide\n  );\n  event OperationCreated(bytes32 operation, uint256 howMany, uint256 ownersCount, address proposer);\n  event OperationUpvoted(bytes32 operation, uint256 votes, uint256 howMany, uint256 ownersCount, address upvoter);\n  event OperationPerformed(bytes32 operation, uint256 howMany, uint256 ownersCount, address performer);\n  event OperationDownvoted(bytes32 operation, uint256 votes, uint256 ownersCount, address downvoter);\n  event OperationCancelled(bytes32 operation, address lastCanceller);\n\n  // ACCESSORS\n\n  function isOwner(address wallet) public view returns (bool) {\n    return ownersIndices[wallet] > 0;\n  }\n\n  function ownersCount() public view returns (uint256) {\n    return owners.length;\n  }\n\n  function allOperationsCount() public view returns (uint256) {\n    return allOperations.length;\n  }\n\n  // MODIFIERS\n\n  /**\n   * @dev Allows to perform method by any of the owners\n   */\n  modifier onlyAnyOwner() {\n    if (checkHowManyOwners(1)) {\n      bool update = (insideCallSender == address(0));\n      if (update) {\n        insideCallSender = msg.sender;\n        insideCallCount = 1;\n      }\n      _;\n      if (update) {\n        insideCallSender = address(0);\n        insideCallCount = 0;\n      }\n    }\n  }\n\n  /**\n   * @dev Allows to perform method only after many owners call it with the same arguments\n   */\n  modifier onlyManyOwners() {\n    if (checkHowManyOwners(howManyOwnersDecide)) {\n      bool update = (insideCallSender == address(0));\n      if (update) {\n        insideCallSender = msg.sender;\n        insideCallCount = howManyOwnersDecide;\n      }\n      _;\n      if (update) {\n        insideCallSender = address(0);\n        insideCallCount = 0;\n      }\n    }\n  }\n\n  /**\n   * @dev Allows to perform method only after all owners call it with the same arguments\n   */\n  modifier onlyAllOwners() {\n    if (checkHowManyOwners(owners.length)) {\n      bool update = (insideCallSender == address(0));\n      if (update) {\n        insideCallSender = msg.sender;\n        insideCallCount = owners.length;\n      }\n      _;\n      if (update) {\n        insideCallSender = address(0);\n        insideCallCount = 0;\n      }\n    }\n  }\n\n  /**\n   * @dev Allows to perform method only after some owners call it with the same arguments\n   */\n  modifier onlySomeOwners(uint256 howMany) {\n    require(howMany > 0, \"onlySomeOwners: howMany argument is zero\");\n    require(howMany <= owners.length, \"onlySomeOwners: howMany argument exceeds the number of owners\");\n\n    if (checkHowManyOwners(howMany)) {\n      bool update = (insideCallSender == address(0));\n      if (update) {\n        insideCallSender = msg.sender;\n        insideCallCount = howMany;\n      }\n      _;\n      if (update) {\n        insideCallSender = address(0);\n        insideCallCount = 0;\n      }\n    }\n  }\n\n  // CONSTRUCTOR\n\n  constructor() {\n    owners.push(msg.sender);\n    ownersIndices[msg.sender] = 1;\n    howManyOwnersDecide = 1;\n  }\n\n  // INTERNAL METHODS\n\n  /**\n   * @dev onlyManyOwners modifier helper\n   */\n  function checkHowManyOwners(uint256 howMany) internal returns (bool) {\n    if (insideCallSender == msg.sender) {\n      require(howMany <= insideCallCount, \"checkHowManyOwners: nested owners modifier check require more owners\");\n      return true;\n    }\n\n    require(ownersIndices[msg.sender] > 0, \"checkHowManyOwners: msg.sender is not an owner\");\n    uint256 ownerIndex = ownersIndices[msg.sender] - 1;\n    bytes32 operation = keccak256(abi.encodePacked(msg.data, ownersGeneration));\n\n    require(\n      (votesMaskByOperation[operation] & (2**ownerIndex)) == 0,\n      \"checkHowManyOwners: owner already voted for the operation\"\n    );\n    votesMaskByOperation[operation] |= (2**ownerIndex);\n    uint256 operationVotesCount = votesCountByOperation[operation] + 1;\n    votesCountByOperation[operation] = operationVotesCount;\n    if (operationVotesCount == 1) {\n      allOperationsIndicies[operation] = allOperations.length;\n      allOperations.push(operation);\n      emit OperationCreated(operation, howMany, owners.length, msg.sender);\n    }\n    emit OperationUpvoted(operation, operationVotesCount, howMany, owners.length, msg.sender);\n\n    // If enough owners confirmed the same operation\n    if (votesCountByOperation[operation] == howMany) {\n      deleteOperation(operation);\n      emit OperationPerformed(operation, howMany, owners.length, msg.sender);\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * @dev Used to delete cancelled or performed operation\n   * @param operation defines which operation to delete\n   */\n  function deleteOperation(bytes32 operation) internal {\n    uint256 index = allOperationsIndicies[operation];\n    if (index < allOperations.length - 1) {\n      // Not last\n      allOperations[index] = allOperations[allOperations.length - 1];\n      allOperationsIndicies[allOperations[index]] = index;\n    }\n    allOperations.pop();\n\n    delete votesMaskByOperation[operation];\n    delete votesCountByOperation[operation];\n    delete allOperationsIndicies[operation];\n  }\n\n  // PUBLIC METHODS\n\n  /**\n   * @dev Allows owners to change their mind by cacnelling votesMaskByOperation operations\n   * @param operation defines which operation to delete\n   */\n  function cancelPending(bytes32 operation) public onlyAnyOwner {\n    uint256 ownerIndex = ownersIndices[msg.sender] - 1;\n    require(\n      (votesMaskByOperation[operation] & (2**ownerIndex)) != 0,\n      \"cancelPending: operation not found for this user\"\n    );\n    votesMaskByOperation[operation] &= ~(2**ownerIndex);\n    uint256 operationVotesCount = votesCountByOperation[operation] - 1;\n    votesCountByOperation[operation] = operationVotesCount;\n    emit OperationDownvoted(operation, operationVotesCount, owners.length, msg.sender);\n    if (operationVotesCount == 0) {\n      deleteOperation(operation);\n      emit OperationCancelled(operation, msg.sender);\n    }\n  }\n\n  /**\n   * @dev Allows owners to change ownership\n   * @param newOwners defines array of addresses of new owners\n   */\n  function transferOwnership(address[] calldata newOwners) public {\n    transferOwnershipWithHowMany(newOwners, newOwners.length);\n  }\n\n  /**\n   * @dev Allows owners to change ownership\n   * @param newOwners defines array of addresses of new owners\n   * @param newHowManyOwnersDecide defines how many owners can decide\n   */\n  function transferOwnershipWithHowMany(address[] calldata newOwners, uint256 newHowManyOwnersDecide)\n    public\n    onlyManyOwners\n  {\n    require(newOwners.length > 0, \"transferOwnershipWithHowMany: owners array is empty\");\n    require(newOwners.length <= 256, \"transferOwnershipWithHowMany: owners count is greater then 256\");\n    require(newHowManyOwnersDecide > 0, \"transferOwnershipWithHowMany: newHowManyOwnersDecide equal to 0\");\n    require(\n      newHowManyOwnersDecide <= newOwners.length,\n      \"transferOwnershipWithHowMany: newHowManyOwnersDecide exceeds the number of owners\"\n    );\n\n    // Reset owners reverse lookup table\n    for (uint256 j = 0; j < owners.length; j++) {\n      delete ownersIndices[owners[j]];\n    }\n    for (uint256 i = 0; i < newOwners.length; i++) {\n      require(newOwners[i] != address(0), \"transferOwnershipWithHowMany: owners array contains zero\");\n      require(ownersIndices[newOwners[i]] == 0, \"transferOwnershipWithHowMany: owners array contains duplicates\");\n      ownersIndices[newOwners[i]] = i + 1;\n    }\n\n    emit OwnershipTransferred(owners, howManyOwnersDecide, newOwners, newHowManyOwnersDecide);\n    owners = newOwners;\n    howManyOwnersDecide = newHowManyOwnersDecide;\n    delete allOperations;\n    ownersGeneration++;\n  }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}